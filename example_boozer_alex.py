##! /opt/homebrew/Caskroom/miniconda/base/envs/scratch/bin/python
'''
Prepare initial conditions for the orbit loss calculation
'''
import numpy as np
from simsopt.mhd import Vmec
from simsopt.field.boozermagneticfield import BoozerRadialInterpolant, InterpolatedBoozerField
from simsopt.util.constants import (
        ALPHA_PARTICLE_MASS as MASS,
        FUSION_ALPHA_PARTICLE_ENERGY as ENERGY,
        ALPHA_PARTICLE_CHARGE as CHARGE
        )
import time
import simsoptpp as sopp

def estimate_max_J(field : BoozerRadialInterpolant):
    '''
    Approximates maximum value of Boozer Jacobian
    by a maximum value on a sampled grid
    '''
    s_grid = np.linspace(0, 1, 100)
    theta_grid = np.linspace(0, 2 * np.pi, 100, endpoint=False)
    zeta_grid = np.linspace(0, 2 * np.pi, 100, endpoint=False)
    [zeta_grid,theta_grid,s_grid] = np.meshgrid(zeta_grid,theta_grid,s_grid)
    points = np.zeros((len(s_grid.flatten()),3))
    points[:,0] = s_grid.flatten()
    points[:,1] = theta_grid.flatten()
    points[:,2] = zeta_grid.flatten()
    field.set_points(points)
    G = field.G()
    iota = field.iota()
    I = field.I()
    modB = field.modB()
    J = (G + iota * I) / (modB**2)
    return np.max(J)

def reactivity(s : float):
    '''
    Computes normalized reactivity of
    alpha particles creation, in Boozer coordinates.
    '''
    T0_keV = 11.5
    max_sigma = T0_keV**(-2/3) * np.exp(-19.94 * T0_keV**(-1/3))
    T = T0_keV * (1 - s)
    n = 1 - s**5
    return n * n * T**(-2/3) * np.exp(-19.94 * T**(-1/3)) / max_sigma

def generate(
        n_particles,
        reactivity,
        field,
        nfp,
        min_s=0.0,
        max_s=1.0,
        save=True
        ):
    '''
    Generates `n_particles` positions of alpha particles
    in equilibrium `field`, sampled from the distriution
    that corresponds to `reactivity` (in Boozer coordinates)
    fusion production rate of alpha particles
    '''
    max_J = estimate_max_J(field)
    s_init = []
    theta_init = []
    zeta_init = []
    for i in range(n_particles):
        while True:
            s = np.random.uniform(min_s, max_s, None)
            theta = np.random.uniform(0, 2 * np.pi, None)
            zeta = np.random.uniform(0, 2 * np.pi / nfp, None)
            field.set_points(np.column_stack((s, theta, zeta)))
            normalized_J = (
                (field.G()[0,0] + field.iota()[0,0]*field.I()[0,0])
                / (field.modB()[0,0]**2) / max_J
                )
            reactivity_per_volume = reactivity(s) * normalized_J
            if (np.random.uniform(0, 1, None) <= normalized_J):
                print(f'Particle sample {i} with {s=}')
                s_init.append(s)
                theta_init.append(theta)
                zeta_init.append(zeta)
                break
    VELOCITY = np.sqrt(2 * ENERGY / MASS)
    vpar_init = np.random.uniform(-VELOCITY, VELOCITY, (n_particles,))
    points = np.zeros((n_particles, 3))
    points[:,0] = np.array(s_init)
    points[:,1] = np.array(theta_init)
    points[:,2] = np.array(zeta_init)
    field.set_points(points)
    mu_per_mass = (VELOCITY**2 - vpar_init**2) / (2 * field.modB()[:,0])

    if save:
        np.savetxt('s0.txt', s_init)
        np.savetxt('theta0.txt', theta_init)
        np.savetxt('zeta0.txt', zeta_init)
        np.savetxt('vpar0.txt', vpar_init)
        np.savetxt('mu_per_mass.txt', mu_per_mass)
    return {
        's0' : s_init,
        'theta0' : theta_init,
        'zeta0' : zeta_init,
        'vpar0' : vpar_init,
        'mu_per_mass' : mu_per_mass
    }

def check_energy(initial_conditions, field):
    '''
    Check that initial conditions for alpha particles in `field`,
    generated by `generate` above, have fusion product energy
    '''
    s0 = initial_conditions['s0']
    theta0 = initial_conditions['theta0']
    zeta0 = initial_conditions['zeta0']
    mu_per_mass = initial_conditions['mu_per_mass']
    vpar0 = initial_conditions['vpar0']
    max_energy_error = 0.0
    for i in range(len(s0)):
        field.set_points(np.column_stack((s0[i], theta0[i], zeta0[i])))
        energy = MASS * (
                vpar0[i]**2 / 2
                + mu_per_mass[i] * field.modB()[0,0]
                )
        print(
            f'#{i} particle {energy=}',
            f'     fusion {ENERGY=}',
            sep='\n'
            )
        assert np.isclose(energy,ENERGY), f'Particle #{i} has wrong energy'
        energy_error = np.abs(np.max(energy - ENERGY))
        if energy_error > max_energy_error:
            max_energy_error = energy_error
    print(
        f'{max_energy_error=} Joules,',
        f'which is {max_energy_error/ENERGY} of fusion born alpha energy',
        sep='\n'
        )

def check_ejp(field):
    ic = {
        's0' : np.loadtxt('ejp/s0.txt'),
        'theta0' : np.loadtxt('ejp/theta0.txt'),
        'zeta0' : np.loadtxt('ejp/zeta0.txt'),
        'mu_per_mass' : np.loadtxt('ejp/mu_per_mass.txt'),
        'vpar0' : np.loadtxt('ejp/vpar0.txt')
        }
    check_energy(ic, field)

# if __name__ == '__main__':

number_of_particles = 1000
vmec_file = 'input.20220218-01-021_QH_A6.5_n0_2.2_T0_10_highResVmecForBestFrom020'
equil_helicity = -4 # Check that this matches boozmn_file!
nfp = 4

print('Attempt to generate initial condition,',
		f'\t{number_of_particles=}',
		f'\tAssumed helicity of the equilibrium {equil_helicity=}',
		sep = '\n'
	)

bri = BoozerRadialInterpolant(
	equil=Vmec(vmec_file),
	order=3 #,
#	N=equil_helicity
	)
# "check_ejp(bri)"

# # input('press ENTER to continue')
# print('Generating initial conditions (ICs):')
# ic = generate(
# 	n_particles=number_of_particles,
# 	reactivity=reactivity,
# 	field=bri,
# 	nfp=nfp,
# 	min_s=0.25,
# 	max_s=0.75,
# 	save=True
# 	)

# print('Checking generated ICs...')
# check_energy(ic, field=bri)
# print('Done.')

# print(ic)

# stz_inits = np.hstack((ic['s0'], ic['theta0'], ic['zeta0']))
s = np.reshape(np.loadtxt('s0.txt'), (number_of_particles, 1))
t = np.reshape(np.loadtxt('theta0.txt'), (number_of_particles, 1))
z = np.reshape(np.loadtxt('zeta0.txt'), (number_of_particles, 1))
vpar = np.reshape(np.loadtxt('vpar0.txt'), (number_of_particles, 1))

stz_inits = np.hstack((s,t,z))

print(stz_inits)
print(vpar)
# stz_inits = np.reshape(stz_inits, (number_of_particles, 3))
stz_inits = np.ascontiguousarray(stz_inits)
# vpar = ic['vpar0']
print('Tracing particles')

degree = 3
n_grid_pts = 15
srange = (0, 1, n_grid_pts)
thetarange = (0, np.pi, n_grid_pts)
zetarange = (0, 2*np.pi/nfp, n_grid_pts)
field = InterpolatedBoozerField(bri, degree, srange, thetarange, zetarange, True, nfp=nfp, stellsym=True)


s_max = 1

srange = (0, s_max, n_grid_pts+1)
trange = (0, 2*np.pi, 2*n_grid_pts+1)
zrange = (0, 2*np.pi/nfp, n_grid_pts+1)

s_grid = np.linspace(srange[0], srange[1], srange[2])
theta_grid = np.linspace(trange[0], trange[1], trange[2])
zeta_grid = np.linspace(zrange[0], zrange[1], zrange[2])

print("theta_grid", theta_grid)
print("zeta_grid", zeta_grid)


print("building quad_pts")
grid_start = time.time()
quad_pts = np.empty((srange[2]*trange[2]*zrange[2], 3))
for i in range(srange[2]):
	for j in range(trange[2]):
		for k in range(zrange[2]):
			quad_pts[trange[2]*zrange[2]*i + zrange[2]*j + k, :] = [s_grid[i], theta_grid[j], zeta_grid[k]]
grid_end = time.time()
print("building grid time=", grid_end - grid_start)
print(quad_pts.shape)

print("building interpolation info")
interp_start = time.time()
field.set_points(quad_pts)
G = field.G()
iota = field.iota()
I = field.I()
modB = field.modB()
J = (G + iota*I)/(modB**2)
# minJ = np.min(J)
maxJ = np.max(J)
print("maxJ", maxJ)

psi0 = field.psi0

# Quantities to interpolate
print("interpolation points")
modB_derivs = field.modB_derivs()
interp_end = time.time()
print("interpolation time = ", interp_end-interp_start)

quad_info = np.hstack((modB, modB_derivs, G, iota))
quad_info = np.ascontiguousarray(quad_info)

t = time.time()
last_time = sopp.gpu_tracing(
	quad_pts=quad_info, 
	srange=srange,
	trange=trange,
	zrange=zrange, 
	stz_init=stz_inits,
	m=MASS, 
	q=CHARGE, 
	vtotal=np.sqrt(2*ENERGY/MASS),  
	vtang=vpar, 
	tmax=1e-2, 
	tol=1e-9, 
	psi0=psi0, 
	nparticles=number_of_particles)
print(last_time)
np.savetxt('timelost_gpu.txt', last_time)
print("tracing time: {}s".format(time.time() - t))
import pandas as pd
df = pd.DataFrame(stz_inits)
filename = "alex_comparison_gpu.csv"
df.columns = ["s", "theta", "zeta"]
df['v_par'] = vpar
df['last_time'] = last_time
df.to_csv(filename, header='column_names')